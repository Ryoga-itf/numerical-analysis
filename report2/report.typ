#import "../template.typ": *
#import "@preview/codelst:2.0.1": sourcecode, sourcefile

#show: project.with(
  week: 2,
  authors: (
    (
      name: sys.inputs.STUDENT_NAME,
      id: sys.inputs.STUDENT_ID,
      affiliation: "情報科学類2年"
    ),
  ),
  date: "2024 年 6 月 17 日",
)

== 課題1
=== (1.1)

コードは以下のようになった。
補間多項式の係数を求め、その後、求めた多項式のグラフと $f(x)$ のグラフ及び 及び補完点を重ねて描画している。

左側のグラフでは $[−1,1]$ の区間で等間隔に取った値を補間点の分布としたものを、
右側では $[0, pi]$ の区間で $theta_i$ を等間隔に取った時の $cos(theta_i)$ の値を補間点の分布としたものを描画している。

#sourcefile(read("src/1-1.jl"), file:"src/1-1.jl")

結果を以下に示す。

補間多項式の係数は以下のようになった。

#sourcecode[```
  normal: 0.499801 - 1.14278*x - 3.37146*x^2 + 12.4799*x^3 + 10.6908*x^4 - 47.234*x^5 - 14.5098*x^6 + 69.2239*x^7 + 6.72901*x^8 - 33.3342*x^9
  cos   : 0.4691 - 0.905097*x - 2.3341*x^2 + 6.17519*x^3 + 5.08622*x^4 - 14.9626*x^5 - 4.91201*x^6 + 15.1669*x^7 + 1.72914*x^8 - 5.48153*x^9
```]

すなわち、
/ $[−1,1]$ の区間で等間隔に取った値を補間点の分布としたもの:
  - $0.499801 - 1.14278x - 3.37146x^2 + 12.4799x^3 + 10.6908x^4 - 47.234x^5 - 14.5098x^6 + 69.2239x^7 + 6.72901x^8 - 33.3342x^9$
/  $[0, pi]$ の区間で $theta_i$ を等間隔に取った時の $cos(theta_i)$ の値を補間点の分布としたもの:
  - $0.4691 - 0.905097x - 2.3341x^2 + 6.17519x^3 + 5.08622x^4 - 14.9626x^5 - 4.91201x^6 + 15.1669x^7 + 1.72914x^8 - 5.48153x^9$

となった。

また、描画した図は以下のようになった。

#figure(
  image("fig/fig1.svg"),
  caption: "課題 1 (1.1) の結果"
)

図を見ると、Runge の現象が確認できる。
特に、$x$ の絶対値が大きい点の間において、大きくずれていることが確認できる。
補完点の分布を工夫したものは $x$ の絶対値が大きい箇所においては比較的乖離した値は出ていない。

== 課題2
=== (2.1)

作成した関数は以下の通り

#sourcefile(read("src/2-1.jl"), file:"src/2-1.jl")

例えば `calcA([1, 2, 4, 8], 4)` を実行すると以下の結果が得られた。

#sourcecode[```
4×4 Matrix{Float64}:
 1.0  1.0   1.0    1.0
 1.0  2.0   4.0    8.0
 1.0  4.0  16.0   64.0
 1.0  8.0  64.0  512.0
```]

=== (2.2)

以下のコードを実行して描画した。

#sourcefile(read("src/2-2.jl"), file:"src/2-2.jl")

結果は以下のようになった。

#figure(
  image("fig/fig2.svg", width: 70%),
  caption: "表1のデータをプロットした結果"
)

=== (2.3)

コードは以下の通り

#sourcefile(read("src/2-3.jl"), file:"src/2-3.jl")

結果を以下に示す

#figure(
  image("fig/fig3.svg", width: 70%),
  caption: "近似した多項式のグラフを(2.2)のグラフに重ねて表示した結果"
)

=== (2.4)

それぞれ以下のようなプログラムを書き実行した。

#sourcefile(read("src/2-4.jl"), file:"src/2-4.jl")

==== (2.4-1)

$4.280592151994875 [10^(-8) Omega "m"]$

==== (2.4-2)

$65.33316000373105 [℃]$

== 課題3
=== (3.1)

以下に示すコードを書き、実行して確認した。

Julia の `sin` 関数との絶対誤差をグラフ上に表示している。
なお、$n$ を $15$ 以上にすると絶対誤差は 0 となったため省略している。

#sourcefile(read("src/3-1.jl"), file:"src/3-1.jl")

結果は以下のようになった。

#figure(
  image("fig/fig4.svg", width: 70%),
  caption: "課題 3 (3.1) プログラムを実行した結果"
)

=== (3.2)

以下に示すコードを書き、実行した。

#sourcefile(read("src/3-2.jl"), file:"src/3-2.jl")

結果は以下のようになった。

#figure(
  image("fig/fig5.svg", width: 70%),
  caption: "課題3 (3.2) プログラムを実行した結果"
)

=== (3.3)

本課題は、次数 $n$ を十分に大きくすると、項を足し込んでも多項式の値の計算に寄与しなくなる原因を考えろというものである。

$sin(x)$ のマクローリン展開の $2k + 1$ 次の項は

$
(-1)^k x^(2k + 1) / (2k + 1)!
$

であるから $k$ が大きいとき、この項は $0$ に近くなる。
Julia では実数は浮動小数点数（IEEE754形式）で処理されるため、
絶対値が大きな値と小さな値とを加えた場合に小さい方の数値がもつ情報が失われる、いわゆる「情報落ち」が発生する。そのため項を足し込んでも多項式の値の計算に寄与しなくなる。

== 課題4

=== (4.1)

コードは以下のようになった。

#sourcefile(read("src/4-1.jl"), file:"src/4-1.jl")

=== (4.2)

コードは以下のようになった。

#sourcefile(read("src/4-2.jl"), file:"src/4-2.jl")

=== (4.3)

コードは以下のようになった。

#sourcefile(read("src/4-3.jl"), file:"src/4-3.jl")

=== (4.4)

与えられた条件のグラフを描画するために以下のコードを作成し、実行した。
なお、`myexp`、`myexp2`、`myexp3` の定義は省略している。

#sourcefile(read("src/4-4.jl"), file:"src/4-4.jl")

次に結果を以下に示す。
なお、左上、右上、左下、右下の順に：
- $n = 200$ で区間が $[-50, 50]$
- $n = 1000$ で区間が $[-50, 50]$
- $n = 200$ で区間が $[-500, 500]$
- $n = 1000$ で区間が $[-500, 500]$

のグラフを描画している。また、すべてのグラフにおいて $y$ 軸が片対数グラフである。

#figure(
  image("fig/fig6.svg"),
  caption: "課題4のプログラムを実行した結果"
)
